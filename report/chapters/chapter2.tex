\chapter{Background Research \& Notation}
\label{chapter2}
\section{Markov Decision Processes}
The Markov Property states that the future is conditionally independent of the past given the present. A sequential decision-making problem that satisfies the Markov Property is known as a Markov Decision Problem, and can be modelled by a Markov Decision Process (MDP) \cite{10.5555/528623}. Where an agent is able to fully observe its state, the problem can be modelled as an MDP. Conversely, where an agent can only partially observe its state, the problem can be modelled by a Partially Observable Markov Decision Process (POMDP).
Consider an agent playing a perfect information game \cite{vonneumann.morgenstern47}, such as Chess or Go, the agent (and it's opponent) are able to fully observe the state of the game with ease. Conversely, a robot navigating through a maze may not be able to observe its exact state due to uncertainty (which is guaranteed) in its sensors.
\\Within this work we assume that the agent is fully able to observe its state. Furthermore that the environment can be discretised (due to some approximations) and tasks are episodic (there exist some terminal states which indicate the end of a task); hence we consider \textbf{finite}, \textbf{undiscounted} MDPs.
Thus, an MDP is a 4-tuple: $\text{MDP} = (S,A,T,R)$ where:
\begin{itemize}
    \item $S$ is a finite set of states.
    \item $A$ is a finite set of actions.
    \item $T : S \times A \times S \rightarrow [0,1]$ is the transition function, which determines the probability of transitioning from a state $s \in S$ to $s' \in S$ with an action $a \in A$.
    \item $R:S \times A \times S \rightarrow \mathbb{R}$ is the reward function, which determines the reward signal, $r \in \mathbb{R}$ received by the agent from transitioning from a state $s \in S$ to $s' \in S$ with the action $a \in A$. This reward is extrinsic to the agent; it comes from the environment.
\end{itemize}
The transition function, $T$ is a key indicator about the nature of the environment.
If $\forall s,s' \in S, \forall a \in A$, $T(s,a,'s) \in \{0,1\}$, then the environment is deterministic, otherwise it is stochastic.
A deterministic environment is one which there is no variance in the outcomes of action in a given state; taking the same action in the same state always produces the same outcome. Whereas a stochastic (or non-deterministic) environment has uncertainty associated with transitions.
\subsection{Policies}
\subsection{Value Functions}
\subsection{Bellman Equations}
The Bellman Equation determines the expected reward for being in a state $s \in S$ and following a fixed policy $\pi$:
$$V^\pi(s) = R(s, \pi(s)) + \sum_{s'}P(s'|s,\pi(s))V^\pi(s')$$
Where $V^\pi$ is the value function of the policy, $\pi$.\\
The Bellman Optimality equation determines the reward for taking the action giving the highest expected return.
$$V^{\pi*}(s) = \text{argmax}_a{R(s,a) + \sum_{s'}P(s'|s,a)V^{\pi*}(s')}$$
Where $V^{\pi*}$ is the value function of the optimal policy.

\section{Planning and Searching}
Planning involves reasoning on a model of an environment in order to produce a sequence of actions that will achieve a specified goal \cite{DBLP:books/aw/RN2020, Lav06, GhallabNauTraverso04}.
\subsection{Heuristic Search}
Heuristic search uses heuristic functions to guide the exploration of possible solutions.
\subsubsection{A* Search}
A* search is a heuristic search algorithm, which is limited to discrete state and action spaces. It can be difficult to choose the heuristic, the heuristic must be admissable \cite{DBLP:books/aw/RN2020}; this means that it must always underestimate the cost of getting from the current state to the goal, and never overestimate it. An interesting extension of this is LRTA* \cite{KORF1990189}, which is akin to model-based RL. In the context of gridworlds, the chosen heuristic in this work is the Manhattan Distance \cite{krause1973taxicab}.
\subsection{Dynamic Programming}
Dynamic Programming \cite{Bellman:1957, DBLP:books/lib/Bertsekas05} is a problem-solving method which involves breaking down problems into smaller sub-problems, solving them, storing the solutions, and combining them to solve the original problem. Given a perfect model of the environment, embedded in an MDP, an optimal policy can be computed using Dynamic Programming, through both Policy Iteration  and Value Iteration.
\subsection{Policy Improvement}
Policy Improvement \cite{Bellman:1957} is the process of generating a policy from a suboptimal policy \cite{DBLP:books/lib/Bertsekas05}.
\subsection{Policy Iteration}
\cite{Bellman:1957, howard:dp}
\subsection{Value Iteration}
\cite{series/synthesis/2010Szepesvari}
\section{Reinforcement Learning}
Reinforcement Learning (RL) does not fall into either of the traditional machine learning paradigms (supervised and unsupervised learning); it is a machine learning paradigm of its own \cite{DBLP:journals/corr/cs-AI-9605103}.
A RL problem comes in the form of a sequential-decision making problem within an environment. A sequential-decision making problem is a problem within which the consequences of actions may not be known until long after they are taken \cite{barto1990learning}. The decision-making agent learns how to behave in an environment by interacting with the environment, at discrete time steps, through actions and observing the affects through its new state and a scalar reward signal, which may be delayed. The goal of the agent is to learn how to map states to actions in order to maximise the cumulative long-term reward \cite{Sutton1998}. The behaviour that the agent learns is called the \textbf{policy}, which is the mapping from states to actions. The \textbf{value function} indicates the expected cumulative reward the agent can receive starting from a given state, given the current knowledge of the agent obtained through its experiences thus far.

\subsection{Model-Free versus Model-Based RL}
Model-Free (or direct) RL is the traditional instantiation of RL, where an agents learns to act in an environment with no knowledge, or consideration, of its dynamics.
Model-based (or indirect) RL is where an agent uses a known or learned model (in the form of an MDP) to learn a global solution \cite{MAL-086}. The learned model may be approximate or exact. The agent may learn the model and the global solution at the same time, as in the Dyna family \cite{Sutton:1990, 10.1145/122344.122377} or learn a global solution by planning over a known model, as in AlphaZero \cite{DBLP:journals/corr/abs-1712-01815} or plan over a learned model, as in MuZero \cite{DBLP:journals/corr/abs-1911-08265}.

% The agent learns to act in the environment by either learning or being provided with a representation of the dynamics of the environment.
% Model-based RL is where the agent learns to act in an environment, and has some understanding of the dynamics of the environment in the form of a model. By the nature of models, the model is inaccurate, more often than not. \cite{Sutton:1990, MAL-086, 10.1145/122344.122377, Kuvayev1996ModelBasedRL, RLSOTA11}
\subsection{Temporal Difference Learning}
The (temporal) credit assignment problem \cite{Minsky:1961:ire} is the problem of determining which actions led to an outcome, and assigning credit among them; it's often the case that a sequence of actions led to an outcome, rather than a single action. In the context of RL, temporal credit assignment is important because in order to maximise the cumulative long-term reward, the agent needs to know which actions will realise such outcome. Temporal Difference (TD) \cite{10.5555/911176, 5392560, 5391906} learning uses this concept; learning is driven by the error/difference between temporally successive predictions, so learning occurs whenever there is a change in prediction over time. It's a method for learning to predict; learning a prediction from another later learned prediction.
TD Learning algorithms can be on-policy, such as SARSA \cite{rummery:cuedtr94}, where the value of the policy being currently carried out by the agent is learnt, or off-policy, such as Q-Learning \cite{Watkins:1989, journals/ml/WatkinsD92}, where the value of the optimal policy is learnt independently of the agent's actions following the current policy \cite{PooleMackworth17}.
\subsubsection{Q-Learning}
Q-Learning is an off-policy Temporal Difference Learning method. It learns an estimate of the expected cumulative reward for each state-action pair, this is known a the Q-value. Q-values are iteratively updated using the Bellman equation, the update rule is as follows:
$$Q(s_t,A_t) \leftarrow Q(s_t,a_t) + \alpha[r_{t+1} + \max_aQ(s_{t+1}, a) -Q(s_t,a_t)]$$
Where $0 \le \alpha \le 1$ is the learning rate, which indicates how quickly learning occurs.
\\Clearly Q-Learning comes from Dynamic Programming, and in that sense it is a tabular method; a Q-table is maintained which stores the Q-values for each state-action pair. For this reason, it doesn't scale too well to large state/action spaces - however it is suitable for the domains that we consider within this work.
\\The result of Q-Learning is that a deterministic, greedy policy is learned.

\section{Exploration Methods in RL}
Thrun \cite{Thrun-1992-15850} distinguished exploration methods in to two main categories: directed and undirected. Directed exploration refers to exploration that is informed by memory about the state space, whereas undirected exploration is uninformed, random. Due to the advances in exploration methods, these categories became redundant, and Amin et al's \cite{DBLP:journals/corr/abs-2109-00157} comprehensive survey on exploration in RL distinguished between reward-free and reward-based exploration; each of these categories is then broken down into memory-free (undirected) and memory-based (directed) exploration. We consider this taxonomy of exploration methods.
\subsection{Random Exploration}
Due to simplicity of implementation and ease of generalisation, random exploration is the most popular form of exploration, and is widely seen in the literature; even where some other exploration method is used, there is often some underlying randomness.
\subsubsection{Random Walk}
A Random Walk, or unguided random search \cite{anderson86}, arises from randomly sampling actions with uniform probability. This is perhaps the most naive method of exploration, since it is entirely random. The agent only explores and doesn't exploit; unless it learns a value function whilst exploring which it switches to exploit after some number of discrete time steps.
\subsubsection{$\epsilon$-greedy}
$\epsilon$-greedy \cite{Watkins:1989, conf/nips/Sutton95} uses a hyperparameter, $0 \le \epsilon \le 1$ to balance between exploration and exploitation. With probability $\epsilon$ the agent explores by taking a random action, with probability $1-\epsilon$ the agent exploits by taking the current best action.
\subsubsection{$\epsilon z$-greedy}
$\epsilon z$-greedy \cite{dabney2021temporallyextended} is an extension to $\epsilon$-greedy that uses temporal persistence; the agent follows a sequence of actions (an option) until termination with probability $\epsilon$ and with probability $1-\epsilon$ the agent exploits by taking the current best action.
% \begin{itemize}
%     \item Pure random exploration: Random Walk
%     \item $\epsilon$-greedy \cite{Watkins:1989, conf/nips/Sutton95}
%     \item $\epsilon z$-geedy \cite{dabney2021temporallyextended, SUTTON1999181}
%     \item Softmax
%     \item Boltzmann \cite{Watkins:1989, 10.1007/BF00992699, SCC.Barto.Bradtke.ea1991}
% \end{itemize}
\subsection{Intrinsically Motivated Exploration}
\subsection{Optimistic}
\begin{itemize}
    \item
\end{itemize}
\subsection{Model-Based}
We refer to Model-Based exploration as any method of exploration that uses a model to influence exploration. For instance, a simple form of model-based RL where an agent plans on an initial model, and performs model-learning concurrently is an exploration method; although a naive one, that doesn't work in practice.
\subsubsection{DARLING}
DARLING \cite{AIJ16-leonetti} computes a partial policy from a deterministic model which it then performs $\epsilon$-greedy on. This leads to constraining exploration to a set of seemingly reasonable states, enabling the agent to overcome inaccuracies in the model, although the model is not explicitly learned.
\subsubsection{PEORL}
PEORL \cite{DBLP:journals/corr/abs-1804-07779}
\subsubsection{Plan-Q Learning}
\cite{10.1007/978-3-540-77949-0_6}
\subsubsection{FRAP}
\cite{DBLP:journals/corr/abs-2006-15009}
\subsubsection{Guided Dyna-Q}
\cite{Hayamizu2021GuidingRE}
\subsection{TMP}
\cite{Jiang2019TaskMotionPW}

% Randomnes underlies most exploration strategies in RL, from using pure-randomness, to randomly samplin
% \subsection{Random}
% \subsubsection{$\epsilon$-greedy}
% $\epsilon$-greedy \cite{Watkins:1989, conf/nips/Sutton95} aims to balance exploration and exploitation through an $\epsilon$ factor, such that the agent exploits its learned knowledge, taking the current best action, with probability $1-\epsilon$ and explores randomly with probability $\epsilon$. It's common to decay $\epsilon$ temporally, so that the agent explores a lot early on and then exploits more after it has learnt for a while. Whilst this method offers a nice balance between the two extremes of pure exploration and pure exploitation, it only provably converges to an optimal policy with an infinite number of observations, so in-fact it is quite inefficient. Furthermore, due to the random nature, it results in continually evaluating sub-optimal actions. A key drawback to $\epsilon$-greedy is that without infinite observations, it can easily get stuck in a local optima.
% \subsubsection{$\epsilon z$-greedy}
% Dabney, et al., \cite{dabney2021temporallyextended} stated that another key problem with $\epsilon$-greedy is its lack of temporal persistence; actions are only performed for one time-step. They proposed $\epsilon z$-greedy, or temporally extended $\epsilon$-greedy, where the agent takes the current best action with probability $1-\epsilon$ and follows an "option" until termination with probability $\epsilon$. An "option" is a sequence of actions, akin to a "plan" in the planning literature.
% \subsubsection{Boltzmann}
% \subsubsection{Thompson Sampling}
% \subsubsection{UCB}
% \subsubsection{Conclusion}
% \subsection{Intrinsically Motivated}
% \subsubsection{Count-based}
% \subsubsection{Information Theoretic}
% \subsubsection{Curiosity Driven}
% \subsection{Model-Based Exploration}
% \subsubsection{DARLING}
% Leonetti et al \cite{AIJ16-leonetti}, developed DARLING (Domain Approximation for Reinforcement Learning), where given a model, a planner is used to produce a "partial policy", which is a set of reasonable choices the agent can make in each state. Exploration is then constrained to this partial policy, and performed using $\epsilon$-greedy. This work showed that whilst planning and RL take two different approches to decision making, on on their own each struggle in stochastic, high-dimensional domains, integrating them can overcome each of their weaknesses. This work was successful in carrying out complex robotics tasks, even with an inaccurate model, and moreover, it showed that the region of the environment that is explored by the agent is more reasonable and is goal-directed.